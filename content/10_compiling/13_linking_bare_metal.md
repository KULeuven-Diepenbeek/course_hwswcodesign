---
title: '1.3 - Linking Bare Metal'
weight: 13
---

With the three object files generated, it is time to stich everything togehter. These object files are compiled, so they are converted to machine code. They are organised in **sections** and they all start at **address 0x0**. (At the bottom of this page, three object dumps are found so you can verify for yourself.) The image below shows which object file contains which sections. As mentioned before, it is the linker's job to do the stiching. A recipe for this can be provided in the form of a **linker script**.

{{% multiHcolumn %}}
{{% column %}}
![sections](/img/10/sections.png)
<hr/>

The linker script shown here, first states that the **entry point** is the label *start*.

Then the available memories are defined. In the case of a RISC processor, the architecture is a **Harvard architecture** (in contrast to the **von Neumann architecture** that is typically found in CISC processors). This implies that the memories for *data* and *instructions* are split. In the definition, two memories are made to facilitate this:

* a ROM:
    * with read-and-execute-rights
    * 2048 bytes in size
    * starts at address 0x0
* a RAM:
    * with read-write-and-execute-rights
    * 2048 bytes in size
    * starts at address 0x800 (2048)
{{% /column %}}
{{% column %}}
{{< code_caption "firmware.lds" >}}
{{< include_file "/src/10/03_firmware.lds" "C" >}}
{{% /column %}}
{{% /multiHcolumn %}}

{{% notice note %}}
It's worth pointing out the difference between **kB** and **KiB**: the base for kB is 10, and the base for KiB is 2.<br/>
*Back-in-the-day* it was custom to state that there are 1024 bytes in a kilobyte. The reason for using 1024 is that this is the power of 2 that is closest to 1000.<br/>
This, however, lead to confusion. After all, there are only 1000 meters in a kilometer. To **avoid this ambiguity**, in 1998 an new set of binary prefixes was introduced. Everything that uses a *base 2* got a new prefix. <br/>
The current defintions hence are: <u>1000 bytes</u> in a **kilobyte** and <u>1024 bytes</u> in a **kibibyte**.<br/><br/>
Similar definitions hold for: mebibyte (MiB), gibibyte (GiB), tebibyte (TiB), ... e.g. 1 TB = 1'000'000'000 bytes and 1 TiB = 1'099'511'627'776 bytes
{{% /notice %}}

After the memories are defined, the script dictates which sections have to put where.

{{% multiHcolumn %}}
{{% column %}}
* The **text** section
    * starts at address 0x0
    * appends the .init sections that can be found in all the object files
    * appends the .text* sections that can be found in all the object files
        * note the trailing wildcard!
    * => is appended to the ROM memory

* The **data** section
    * starts at address 0x0
    * appends the .data sections that can be found in all the object files
    * => is appended to the RAM memory
* The **rodata** section
    * starts at address 0x400 (1024)
    * appends the .rodata sections that can be found in all the object files
    * aligns to 4 bytes, while filling with 0xFF
    * => is appended to the RAM memory
* dicards other sections
{{% /column %}}
{{% column %}}
![linker](/img/10/linker.png)
{{% /column %}}
{{% /multiHcolumn %}}


The image below shows the final picture, for this exercise. With these 5 files (1 header file, 3 C files and a linker script) the final binary file can be generated. This binary is in the *Executable and Linkable Format ([.elf](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format))*

![compile4](/img/10/compile_4.png)

## Making a human-readable format of the .elf

After running the tool chain, an **.elf** file is generated. It might become useful to understand what is going on in this file (as humans). Unfortunately, chances are that a hardware designer needs this to figure out what the implemented processor is doing. 

The generated binary file can be *disassembled* again. Doing this allows to read what was eventually generated by the compiler. Againthe the **riscv32-unknown-elf-objdump** program can come to our rescue. The object dumper can be used to disassemble the .elf by using the **-D** option.

The disassembly of the .elf file shows all the instructions with the **address**, the **machine code** of the instruction and the human readable **mnemonic**.

{{< code_caption "objdump of firmware.elf" >}}
{{< include_file "/src/10/03_firmware.elf.objdump" "S" >}}



## The objdumps

Below are the object dumps of **start.o**, **print.o**, and **firmware.o**. 

{{% multiHcolumn %}}
{{% column %}}
{{< code_caption "objdump of start.o" >}}
{{< include_file "/src/10/03_start.objdump" "S" >}}
{{% /column %}}
{{% column %}}
{{< code_caption "objdump of print.o" >}}
{{< include_file "/src/10/03_print.objdump" "S" >}}
{{% /column %}}
{{% column %}}
{{< code_caption "objdump of firmware.o" >}}
{{< include_file "/src/10/03_firmware.objdump" "S" >}}
{{% /column %}}
{{% /multiHcolumn %}}
