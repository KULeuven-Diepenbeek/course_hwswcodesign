<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2 Making it work on hardware on HW/SW codesign</title>
    <link>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/</link>
    <description>Recent content in 2 Making it work on hardware on HW/SW codesign</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-uk</language>
    <managingEditor>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Jo Vliegen)</managingEditor>
    <webMaster>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Jo Vliegen)</webMaster>
    <atom:link href="https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2.1 - The current situation</title>
      <link>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/21_current_situation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/21_current_situation/</guid>
      <description>Take a moment to assess what has been done so far. An implementation has been made of a RISCV32i Software has been written in C Crosscompilation was done to obtain an .elf file Python scripts are used to generate a hex file A testbench has been run to check the correctness of both hardware and software The main question that will posed in this course is: &amp;ldquo;What&amp;rsquo;s the performance and the cost?</description>
    </item>
    <item>
      <title>2.2 - Wrapping it up</title>
      <link>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/22_wrapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/22_wrapping/</guid>
      <description>Before the resource utilisation table can be extracted, a number of things need to be taken care of first.&#xA;Clock and Reset The two most important signals are clock. Without this signals there can be no synchronous design. In an FPGA this signal is taken care of very well to such extend that it even has its own routing network. To allow a signal access to this clocking network, dedicated buffers are available (e.</description>
    </item>
    <item>
      <title>2.3 - One more thing ...</title>
      <link>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/23_onemore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/23_onemore/</guid>
      <description>The implementation of the RISC-V that is used in this course, is a single-cycle implementation. Nonetheless, in earlier courses you might have already seen how pipelining has a huge effect on the implementation. The major advantage of a single-cycle implementation is that it is rather simple to understand and implement. The major drawback is that is not as performant, but it going to get even worse.&#xA;In the previous section, it was shown that the BRAM needs at least one clock cycle to read from the memory.</description>
    </item>
    <item>
      <title>2.4 - Go as fast as you can</title>
      <link>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/24_ooc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/24_ooc/</guid>
      <description>This chapter has introduced the use of a digital clock manager. A nice feature that comes from using such a primitive is that you can set the desired clock frequency to a value that suits your implementation like a glove. Although that is a nice feature, the question arises: &amp;ldquo;What is the maximal frequency?&amp;rdquo;. As you (hopefully) know by know, the maximal frequency is determined by the critical path.&#xA;The critical path in digital circuit design refers to the longest sequence of dependent operations that determine the minimum clock period, and thus the maximum clock frequency.</description>
    </item>
    <item>
      <title>2.5 - Exercises</title>
      <link>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/25_exercises/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>&lt;i&gt;fname&lt;/i&gt;.&lt;i&gt;lname&lt;/i&gt;A T&lt;i&gt;kuleuven.be&lt;/i&gt; (Jo Vliegen)</author>
      <guid>https://kuleuven-diepenbeek.github.io/course_hwswcodesign/20_hw/25_exercises/</guid>
      <description>Practice makes perfect Below are a number of programming exercises.&#xA;Exercise 201 Gather all the info from this chapter and apply them to your implementation so you end up with a synthesisable design. Then, write software that puts a counter on the 4 LEDS. The period should be rouhgly around 1Hz so the correct working can be easily verified with the naked eye.&#xA;Exercise 202 Find the highest possible frequency at which your RISC-V implementation can operate, while still meeting the timing requirements.</description>
    </item>
  </channel>
</rss>
